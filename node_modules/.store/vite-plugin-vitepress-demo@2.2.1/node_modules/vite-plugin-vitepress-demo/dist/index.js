// src/constant.ts
var VITEPRESS_ID = "@siteDemo";
var ALIAS = "/@site-demos";
var VITEPRESS_ID_PATH = `/${VITEPRESS_ID}`;

// src/parser/watcher.ts
import chokidar from "chokidar";
import { normalizePath } from "vite";
import fg from "fast-glob";

// src/tools/block.ts
import MagicString from "magic-string";
import { parse } from "vue/compiler-sfc";
var Block = class {
  constructor(watcher, id, file) {
    this.watcher = watcher;
    this.id = id;
    this.file = file;
    this.ext = id.split(".").pop();
  }
  ext;
  sfc;
  magicString;
  code;
  raw;
  blockData = {};
  renderData;
  get isVue() {
    return this.ext === "vue";
  }
  get isJsx() {
    return this.ext === "jsx" || this.ext === "tsx";
  }
  get isVueOrJsx() {
    return this.isVue || this.isJsx;
  }
  get tools() {
    return this.watcher.commonTools;
  }
  get isRaw() {
    return this.raw;
  }
  get shortPath() {
    return this.id;
  }
  get fullPath() {
    return this.file;
  }
  get md() {
    return this.tools.md;
  }
  async load(code, raw) {
    this.raw = raw ?? !(this.isJsx || this.isVue);
    if (!code)
      code = await this.tools.read(this.file);
    this.code = code;
    this.magicString = new MagicString(code);
    this.sfc = parse(code);
    if (this.isVue && !this.raw)
      this.parserCustomBlock();
    this.tools.hotReloadModule();
  }
  parserCustomBlock() {
    const { descriptor } = this.sfc;
    const { customBlocks } = descriptor;
    if (customBlocks.length) {
      customBlocks.forEach((block) => {
        if (block.type === "docs") {
          this.magicString.remove(block.loc.start.offset, block.loc.end.offset);
          this.magicString.replace(/<docs[^>]*>.*?<\/docs>/gs, "");
          const env = {};
          const data = this.md?.render(block.content.trim(), env);
          const item = {
            title: encodeURIComponent(env?.frontmatter?.title || env?.title || ""),
            content: encodeURIComponent(data || "")
          };
          if (env.frontmatter?.codesandbox)
            item.codesandbox = encodeURIComponent(env.frontmatter.codesandbox);
          if (env.frontmatter?.codepen)
            item.codepen = encodeURIComponent(env.frontmatter.codepen);
          if (env.frontmatter?.stackblitz)
            item.stackblitz = encodeURIComponent(env.frontmatter.stackblitz);
          if (block.lang)
            this.blockData[block.lang] = item;
          else
            this.blockData.default = item;
        }
      });
    }
  }
  toString() {
    if (this.raw)
      return this.code;
    return this.magicString?.toString().trim();
  }
  transform() {
    return {
      code: this.magicString?.toString().trim(),
      map: this.magicString?.generateMap({ hires: true })
    };
  }
  valueOf() {
    return this.toString();
  }
  resetRenderData() {
    this.renderData = void 0;
  }
  getRenderData() {
    if (this.renderData)
      return this.renderData;
    const data = `\`\`\`${this.ext ?? "vue"}
${this.toString()}
\`\`\``;
    const render2 = this.md?.render(data);
    this.renderData = render2;
    return render2;
  }
  toJson() {
    return {
      block: this.blockData,
      code: this.toString() ? encodeURIComponent(this.toString()) : "",
      render: this.getRenderData() ? encodeURIComponent(this.getRenderData()) : ""
    };
  }
};

// src/tools/obj-to-str.ts
var isString = (val) => typeof val === "string";
var isNumber = (val) => typeof val === "number";
var isBoolean = (val) => typeof val === "boolean";
var isBase = (val) => val === null || isNumber(val) || isBoolean(val) || val === void 0;
var objToStr = (obj, isDeep = 1) => {
  let str = "{";
  for (const strKey in obj) {
    const value = obj[strKey];
    if (strKey === "comp" && isDeep === 2) {
      str += `${strKey}: ${value},`;
    } else if (isString(value)) {
      str += `'${strKey}': \`${value}\`,`;
    } else if (isBase(value)) {
      str += `'${strKey}': ${value},`;
    } else if (Array.isArray(value)) {
      str += `'${strKey}': [`;
      for (const item of value) {
        if (isString(item))
          str += `'${item}',`;
        else if (isBase(item))
          str += `${item},`;
        else
          str += `${objToStr(item, isDeep + 1)},`;
      }
      str = `${str.endsWith(",") ? str.slice(0, str.length - 1) : str}],`;
    } else {
      str += `'${strKey}': ${objToStr(value, isDeep + 1)},`;
    }
  }
  return `${str.slice(0, str.length > 1 ? str.length - 1 : str.length)}}`;
};

// src/parser/file-cache.ts
var FileCache = class {
  constructor(tools) {
    this.tools = tools;
  }
  cacheFile = /* @__PURE__ */ new Map();
  get(path) {
    return this.cacheFile.get(path);
  }
  set(path, value) {
    this.cacheFile.set(path, value);
  }
  delete(path) {
    this.cacheFile.delete(path);
  }
  has(path) {
    return this.cacheFile.has(path);
  }
  toString() {
    const obj = {};
    this.cacheFile.forEach((value) => {
      const shortKey = value.shortPath;
      const path = `${ALIAS}/${shortKey}`;
      const comp = `() => import(/* @vite-ignore */\`${path}\`)`;
      obj[shortKey] = {
        data: value.toJson()
      };
      if (!value.isRaw)
        obj[shortKey].comp = comp;
    });
    const data = objToStr(obj);
    return `export default ${data}`;
  }
};

// src/parser/watcher.ts
var Watcher = class {
  constructor(tools) {
    this.tools = tools;
    this.fileCache = new FileCache(tools);
  }
  w;
  shortPathCache = /* @__PURE__ */ new Map();
  fileCache;
  hasFile(file) {
    return this.fileCache.has(file);
  }
  getFile(file) {
    return this.fileCache.get(file);
  }
  getBlock(file) {
    return this.fileCache.get(file);
  }
  getShortPath(file) {
    return this.shortPathCache.get(file);
  }
  setShortPath(file, path) {
    this.shortPathCache.set(file, path);
  }
  transform(_code, id) {
    const block = this.getBlock(id);
    if (block && block.isVueOrJsx) {
      return block.transform();
    }
  }
  add(file) {
    this.w?.add(file);
  }
  get commonTools() {
    return this.tools;
  }
  async setup() {
    if (this.tools.mode === "development") {
      this.w = chokidar.watch(this.tools.glob, {
        cwd: this.tools.srcDir,
        ignored: this.tools.ignore
      });
    }
    const fileList = await fg(this.tools.glob, {
      cwd: this.tools.srcDir,
      ignore: this.tools.ignore
    });
    if (fileList.length) {
      for (const file of fileList)
        await this.addWatcherFile(file);
    }
    if (this.tools.mode === "development") {
      this.addWatcher();
      this.unlinkWatcher();
      this.changeWatcher();
    }
  }
  async addWatcherFile(file) {
    const fullPath = this.tools.getFullPath(file);
    file = normalizePath(file);
    this.shortPathCache.set(file, fullPath);
    const block = new Block(this, file, fullPath);
    this.fileCache.set(fullPath, block);
    await block.load();
  }
  addWatcher() {
    this.w?.on("add", async (file) => {
      await this.addWatcherFile(file);
    });
  }
  async changeWatcherFile(file) {
    file = normalizePath(file);
    const fullPath = this.tools.getFullPath(file);
    if (this.fileCache.has(fullPath))
      this.fileCache.delete(fullPath);
    if (!this.shortPathCache.has(file))
      this.shortPathCache.set(file, fullPath);
    const block = new Block(this, file, fullPath);
    this.fileCache.set(fullPath, block);
    await block.load();
  }
  changeWatcher() {
    this.w?.on("change", async (file) => {
      await this.changeWatcherFile(file);
    });
  }
  async unlinkWatcherFile(file) {
    file = normalizePath(file);
    const fullPath = this.tools.getFullPath(file);
    if (this.fileCache.has(fullPath))
      this.fileCache.delete(fullPath);
    if (this.shortPathCache.has(file))
      this.shortPathCache.delete(file);
    this.tools.hotReloadModule();
  }
  unlinkWatcher() {
    this.w?.on("unlink", async (file) => {
      await this.unlinkWatcherFile(file);
    });
  }
  load() {
    return this.fileCache.toString();
  }
  close() {
    this.w?.close();
  }
};

// src/tools/index.ts
import { normalizePath as normalizePath2 } from "vite";
import fsExtra from "fs-extra";
import { createMarkdownRenderer } from "vitepress";
var Tools = class {
  constructor(options) {
    this.options = options;
  }
  md;
  server;
  config;
  vitepress;
  ssr = false;
  dev = true;
  get base() {
    return this.vitepress?.site.base || this.config?.base || "/";
  }
  get markdownOptions() {
    return this.vitepress?.markdown;
  }
  get logger() {
    return this.config.logger;
  }
  get mode() {
    return this.config?.mode ?? "development";
  }
  async setupConfig(config) {
    this.config = config;
    this.vitepress = config.vitepress;
    this.md = await createMarkdownRenderer(this.srcDir, this.markdownOptions, this.base, this.logger);
  }
  checkSSR(ssr) {
    this.ssr = ssr ?? false;
  }
  checkDev(dev) {
    this.dev = dev ?? true;
  }
  async setupServer(server) {
    this.server = server;
  }
  /**
     * 获取当前的资源路径地址
     * @param config
     */
  baseDir(config) {
    const path = this.options.srcDir ?? config?.root ?? this.config?.root ?? process.cwd();
    return normalizePath2(path);
  }
  getFullPath(file) {
    return normalizePath2(`${this.srcDir}/${file}`);
  }
  async read(file) {
    return fsExtra.readFile(file, "utf-8");
  }
  hotReloadModule() {
    if (!this.dev)
      return;
    const module = this.server?.moduleGraph.getModuleById(VITEPRESS_ID_PATH);
    if (module)
      this.server?.reloadModule(module);
  }
  /**
     * 获取当前的资源路径地址
     */
  get srcDir() {
    return this.baseDir();
  }
  /**
   * 获取当前的需要被监听的文件夹
   */
  get glob() {
    return this.options.glob ?? ["**/demos/**/*.{vue,tsx,jsx}", "**/demo/**/*.{vue,jsx,tsx}"];
  }
  get ignore() {
    const defaultIgnore = [
      "**/node_modules/**",
      "**/.git/**",
      "**/demos/**/node_modules/**",
      "**/demos/**/.git/**",
      "**/tests/**",
      "**/test/**",
      "**/__tests__/**",
      "**/__test__/**",
      "**/tests.*",
      "**/test.*",
      "**/*.test.*",
      "**/.idea/**",
      "**/.vscode/**",
      "**/dist/**",
      "**/build/**",
      "**/.vitepress/**"
    ];
    if (this.options.ignore) {
      if (typeof this.options.ignore === "string")
        return [...Array.from(/* @__PURE__ */ new Set([this.options.ignore, ...defaultIgnore]))];
      return [...Array.from(/* @__PURE__ */ new Set([...this.options.ignore, ...defaultIgnore]))];
    }
    return defaultIgnore;
  }
  /**
   * 检查当前是不是服务端渲染
   */
  get isSSR() {
    return this.ssr;
  }
  get wrapper() {
    return this.options?.wrapper ?? "demo";
  }
};

// src/parser/load-md.ts
import { dirname, resolve } from "path";
import MagicString2 from "magic-string";
import { parseDocument } from "htmlparser2";
import { render } from "dom-serializer";
import { normalizePath as normalizePath3 } from "vite";

// src/parser/watch-queue.ts
import chokidar2 from "chokidar";
var WatchQueue = class {
  constructor(tools, watcher) {
    this.tools = tools;
    this.watcher = watcher;
  }
  queue = /* @__PURE__ */ new Map();
  add(file) {
    if (this.tools.mode !== "development")
      return;
    if (this.queue.has(file))
      return;
    const watcher = chokidar2.watch(file, {
      cwd: this.tools.srcDir
    });
    watcher.on("change", async (file2) => {
      await this.watcher.addWatcherFile(file2);
    });
    watcher.on("unlink", async () => {
      await this.watcher.unlinkWatcherFile(file);
      this.delete(file);
    });
    this.queue.set(file, watcher);
  }
  delete(file) {
    if (this.tools.mode !== "development")
      return;
    const watcher = this.queue.get(file);
    if (watcher) {
      watcher.removeAllListeners();
      watcher.close().then(() => {
      });
      this.queue.delete(file);
    }
  }
};

// src/parser/load-md.ts
var LoadMd = class {
  constructor(tools, watcher) {
    this.tools = tools;
    this.watcher = watcher;
    this.watchQueue = new WatchQueue(tools, watcher);
  }
  watchQueue;
  get wrapper() {
    return this.tools.wrapper;
  }
  async parserSrc(src, id, raw) {
    const dirPath = normalizePath3(dirname(id));
    const fullPath = normalizePath3(resolve(dirPath, src));
    const demoPath = normalizePath3(fullPath.replace(normalizePath3(`${this.tools.srcDir}/`), ""));
    if (raw) {
      if (!this.watcher.hasFile(fullPath)) {
        this.watchQueue.add(demoPath);
        await this.watcher.addWatcherFile(demoPath);
      }
    }
    return demoPath;
  }
  async parserDemo(str, demo, id) {
    const { content } = demo;
    const dom = parseDocument(content);
    for (const child of dom.children) {
      if (child.type === "tag" && child.name === this.wrapper) {
        const src = child.attribs.src;
        const raw = "raw" in child.attribs;
        if (src) {
          child.attribs.src = await this.parserSrc(src, id, raw);
        } else {
          console.log("[vitepress:demo]: demo src is required");
        }
      }
    }
    const newContent = render(dom);
    if (content !== newContent)
      str.replace(content, newContent);
  }
  async replaceDemo(str, demos, id) {
    for (const demo of demos)
      await this.parserDemo(str, demo, id);
  }
  checkWrapper(token) {
    const REGEX_DEMO = new RegExp(`<${this.wrapper}.*?>(.*?)</${this.wrapper}>`, "gis");
    const REGEX_DEMO1 = new RegExp(`<${this.wrapper}.*?/>`, "gis");
    return REGEX_DEMO.test(token) || REGEX_DEMO1.test(token);
  }
  getDemo(tokens) {
    const demos = [];
    for (const token of tokens) {
      if (token.type === "html_block" || token.type === "html_inline" || token.type === "inline") {
        const isDemo = this.checkWrapper(token.content);
        if (isDemo) {
          demos.push({
            content: token.content,
            map: token.map
          });
        }
      }
    }
    return demos;
  }
  async transform(code, id) {
    if (!id.endsWith(".md"))
      return;
    const ms = new MagicString2(code);
    const tokens = this.tools.md?.parse(code, {});
    this.tools.md?.render(code, {});
    const demos = this.getDemo(tokens);
    await this.replaceDemo(ms, demos, id);
    return {
      code: ms.toString(),
      map: ms.generateMap({ hires: true })
    };
  }
};

// src/index.ts
function vitepressDemo(opt) {
  const tools = new Tools(opt ?? {});
  const watcher = new Watcher(tools);
  const loadMd = new LoadMd(tools, watcher);
  return {
    name: "vitepress:demo",
    enforce: "pre",
    config(_config, env) {
      tools.checkSSR(env.isSsrBuild);
      tools.checkDev(env.command === "serve");
      return {
        resolve: {
          alias: [
            { find: ALIAS, replacement: tools.baseDir(_config) },
            { find: VITEPRESS_ID, replacement: VITEPRESS_ID_PATH }
          ]
        },
        ssr: {
          noExternal: ["vite-plugin-vitepress-demo"]
        }
      };
    },
    resolveId(id) {
      if (id.endsWith(VITEPRESS_ID))
        return VITEPRESS_ID_PATH;
    },
    async configResolved(c) {
      await tools.setupConfig(c);
      await watcher.setup();
    },
    async configureServer(s) {
      await tools.setupServer(s);
    },
    async transform(code, id) {
      const content = watcher.transform(code, id);
      if (content)
        return content;
      return loadMd.transform(code, id);
    },
    load(id) {
      if (id === VITEPRESS_ID)
        console.log("SAdsadsa");
      if (id === VITEPRESS_ID_PATH)
        return watcher.load();
    }
  };
}
var src_default = vitepressDemo;
export {
  src_default as default,
  vitepressDemo
};
